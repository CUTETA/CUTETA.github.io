<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>F1C100S踩坑记录（四）</title>
      <link href="/2022/03/06/F1C100S-Note4/"/>
      <url>/2022/03/06/F1C100S-Note4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-驱动开发"><a href="#Linux-驱动开发" class="headerlink" title="Linux 驱动开发"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow">Linux 驱动开发</i></h1><h2 id="LED-驱动开发（有部分-BUG-）"><a href="#LED-驱动开发（有部分-BUG-）" class="headerlink" title=" LED 驱动开发（有部分 BUG ）"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> LED 驱动开发（有部分 BUG ）</i></h2><p>​            前面学习了系统移植，接下来学习驱动开发。老规矩咱身为一名精通点灯技术的 ctrl c v 工程师🧔 接下来将学习如何编写 Linux 下的 LED 驱动。我们先看下 F1C100S 核心板的原理图（如 图34 所示）</p><p><img src="/2022/03/06/F1C100S-Note4/34.png" alt="34"></p><center>图34</center><p>​        由图可知 Rhino Pi （暂定这个名字😋）板载一个用户 LED 连接在 PE6 上。</p><p><img src="/2022/03/06/F1C100S-Note4/35.png" alt="35"></p><center>图35</center><p>​        先前看到一篇博客，我们可以用 Linux 提供的 GPIO 系统通过 shell 命令进行点灯（后面再介绍用驱动方式来点灯）。下面介绍 GPIO 引脚编号的计算方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引脚编号 = 控制引脚的寄存器基数 + 控制引脚寄存器位数</span><br></pre></td></tr></table></figure><p>​        一般情况下，对于GPIOX_Y的编号 = 控制引脚的寄存器基数（32X）+ 控制引脚寄存器位数（Y）= 32X + Y，例如 PE6 的编号 = 32*4 + 6 = 134。接下来进行点灯，首先要激活引脚：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 134 &gt; /sys/class/gpio/export</span><br></pre></td></tr></table></figure><p>​        设置引脚模式为 [输入] -&gt; in 或 [输出] -&gt; out，这里设置为输出模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo out &gt; /sys/class/gpio/gpio134/direction</span><br></pre></td></tr></table></figure><p>​        设置输出值（由原理图知 value 设为 1 即设为高电平时 LED 灯亮，设置为 0 低电平时 LED 灯灭）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt;/sys/class/gpio/gpio134/value</span><br><span class="line">echo 0 &gt;/sys/class/gpio/gpio134/value</span><br></pre></td></tr></table></figure><p>​        取消引脚导出，当控制完成时，需要释放引脚：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 134 &gt; /sys/class/gpio/unexport</span><br></pre></td></tr></table></figure><video src="F1C100S-Note4/1.mp4"></video><p>​        接下来通过驱动开发方式来点灯，查看 F1C200S 用户手册（PS：因为目前网上只能找到 F1C200S 的手册，F1C100S 与 F1C200S 差别在于内置 DDR 一个是 32MB 一个是 64MB）找到关于 GPIOE 的寄存器地址（如 图36 所示）。</p><p><img src="/2022/03/06/F1C100S-Note4/36.png" alt="36"></p><p><img src="/2022/03/06/F1C100S-Note4/366.png" alt="36"></p><center>图36</center><p>​        通过查表我们得到要用到的寄存器，以 GPIOE_CFG0 为例，<code>设备号 = 主设备号 + 次设备号</code>  即：</p><center>Address=0x01C20800+4*0x24+0x00=0x01C20800+0x90=0x1C20890</center><div class="table-container"><table><thead><tr><th style="text-align:center">Register Name</th><th style="text-align:center">Offset</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">GPIOE_CFG0</td><td style="text-align:center">0x01C20890</td><td style="text-align:center">配置寄存器0</td></tr><tr><td style="text-align:center">GPIOE_DATA</td><td style="text-align:center">0x1C208A0</td><td style="text-align:center">数据寄存器</td></tr><tr><td style="text-align:center">GPIOE_PUL0</td><td style="text-align:center">0x1C208AC</td><td style="text-align:center">上/下拉输出配置</td></tr></tbody></table></div><p>​        知道了寄存器的地址，接下来我们根据这些信息来配置我们需要的引脚，在 Ubuntu 中创建一个目录 <em>Linux_Drivers</em> 用来存放 Linux 驱动程序，接下来新建 <em>led_dev.c</em> 文件编写 LED 驱动程序（如 图38 所示），<a href="https://www.cnblogs.com/qiaoge/archive/2012/03/31/2426282.html">linux驱动头文件说明（转载） - 桥～ - 博客园 (cnblogs.com)</a>    具体操作可查看 <em>【正点原子】I.MX6U嵌入式Linux驱动开发指南V1.6.pdf</em>  里面有详细教程。</p><p><img src="/2022/03/06/F1C100S-Note4/Users\13937\Desktop\笔记\Linux_Note\F1C100S\Image\38.png" alt="38"></p><center>图38</center><p>​        编写完 LED 驱动程序后，接下来编写测试 APP 程序，led 驱动加载成功以后手动创建/dev/led 节点，应用 APP 通过操作/dev/led</p><p>文件来完成对 LED 设备的控制，向/dev/led 文件写 0 表示关闭 LED 灯，写 1 表示打开 LED 灯。新建 ledApp.c 文件编写 LED 应用程序。（如 图39 所示）</p><p><img src="/2022/03/06/F1C100S-Note4/Users\13937\Desktop\笔记\Linux_Note\F1C100S\Image\39.png" alt="39"></p><center>图39</center><p>​        接下来创建 Makefile 脚本，代码如下所示，KERNELDIR 变量表示板子当前运行的 Linux 操作系统的源码（即：内核的源码）的目录。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">KERNELDIR := /home/z/linux/F1C100S/kernel/linux-5.7.1</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line">obj-m := led_dev.o</span><br><span class="line"></span><br><span class="line"><span class="section">kernel_modules:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line"><span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNELDIR)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure><p>​        执行 make 命令编译成功以后就会生成一个名为 led_dev.ko 的驱动模块文件（如 图40 所示）。</p><p><img src="/2022/03/06/F1C100S-Note4/Users\13937\Desktop\笔记\Linux_Note\F1C100S\Image\40.png" alt="40"></p><center>图40</center><p>​        接着输入如下命令编译 ledApp.c 这个测试程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc ledApp.c -o ledApp</span><br></pre></td></tr></table></figure><p>​        将生成的 led.ko 和 ledApp 文件拷贝至 <em>/media/z/rootfs/lib/modules/5.7.1</em>-Rhino Pi （如 图41 所示），因为使用 modprobe 命令来加载驱动。modprobe 命令默认会去 <em>/lib/modules/<kernel-version></kernel-version></em> 目录中查找模块，比如俺使用的 Linux kernel 的版本号为 5.7.1，所以 modprobe 命令默认会到 <em>/lib/modules/5.7.1</em>-Rhino PI* 这个目录中查找相应的驱动模块，一般自己制作的根文件系统中是不会有这个目录的，需要自己手动创建。</p><p><img src="/2022/03/06/F1C100S-Note4/Users\13937\Desktop\笔记\Linux_Note\F1C100S\Image\41.png" alt="41"></p><center>图41</center><p>​        重启开发板进入 <em>/lib/moudles/5.7.1</em>-Rhino PI 目录，输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">depmod //第一次加载驱动的时候需要运行此命令</span><br><span class="line">modprobe led_dev.ko //加载驱动</span><br><span class="line">mknod /dev/led c 200 0//创建 &quot;/dev/led&quot; 设备节点</span><br><span class="line"></span><br><span class="line">./ledApp /dev/led on //打开 LED 灯</span><br><span class="line">./ledApp /dev/led off //关闭 LED 灯</span><br><span class="line"></span><br><span class="line">modprobe -r led_dev.ko  //卸载驱动or rmmod led_dev.ko </span><br></pre></td></tr></table></figure><p>​        如果出现以下报错（如 图42 所示），原因是默认情况下根文件系统不支持该指令，可以通过配置busybox来添加这个功能。</p><p><img src="/2022/03/06/F1C100S-Note4/42.png" alt="42"></p><center>图42</center><p>​        进入 <em>/output/build/busybox-1.27.2</em> 目录，执行 make menuconfig 命令，进入 Linux Module Utilities 菜单，勾选✔上 depmod（如 图43 所示）。</p><p><img src="/2022/03/06/F1C100S-Note4/43.png" alt="43"></p><center>图43</center><p>​        接着将当前目录下的 .config 文件重命名为 busybox.config 后覆盖掉 <em>package/busybox/busybox.config</em> 文件，之后在 buildroot 根目录下重新执行 make 指令编译，busybox 将会自动更新，后更新根文件系统（参考：<a href="https://jan-z.top/2022/03/02/F1C100S-Note3/">根文件系统移植</a>）。</p><p>​        若出现以下情况（如 图44 所示），一般可能是没有执行权限，也可能是缺少库文件。</p><p><img src="/2022/03/06/F1C100S-Note4/44.png" alt="44"></p><center>图44</center><p>​        在 led_dev 目录下输入 <code>arm-linux-gnueabi-readelf -e ledApp</code> ，可以看到提示 [Requesting program interpreter: /lib/ld-linux.so.3] ，通过 <code>find / -name &quot;linux.so.3&quot;</code> 命令找到 linux.so.3 所在的目录，通过 <code>ls -il</code> 命令知道 linux.so.3 软链接 ld-2.25.so ，将其复制到开发板 <em>/lib</em> 目录下并重新软链接。 </p><p><img src="/2022/03/06/F1C100S-Note4/45.png" alt="45"></p><p><img src="/2022/03/06/F1C100S-Note4/46.png" alt="46"></p><h2 id="驱动模块的加载和卸载"><a href="#驱动模块的加载和卸载" class="headerlink" title=" 驱动模块的加载和卸载"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 驱动模块的加载和卸载</i></h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F1C100S踩坑记录（三）</title>
      <link href="/2022/03/02/F1C100S-Note3/"/>
      <url>/2022/03/02/F1C100S-Note3/</url>
      
        <content type="html"><![CDATA[<h2 id="rootfs-根文件系统移植"><a href="#rootfs-根文件系统移植" class="headerlink" title=" rootfs  根文件系统移植"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> rootfs  根文件系统移植</i></h2><p>​        根文件系统和 Linux 内核是分开的，单独的 Linux 内核是没法正常工作的，必须加上根文件系统。如果不提供根文件系统，Linux 内核在启动时会提示 Kernel panic （内核崩溃）。下面将分别使用 busyBox 和 Buildroot 制作根文件系统。</p><h3 id="Buildroot-制作根文件系统"><a href="#Buildroot-制作根文件系统" class="headerlink" title=" Buildroot 制作根文件系统"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> Buildroot 制作根文件系统</i></h3><p>​        安装 Buildroot 软件（<a href="https://buildroot.org/downloads/">下载链接</a>），解压后进入该目录，执行以下命令进入图形配置界面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>​        进入 Target options 选项（架构选择），将 Target Architecture 设置为 ARM 架构 little endian （小端模式），保存返回上一级（如 图21 所示）。</p><blockquote><p>第一个选项：架构选择</p><p>第二个选项：输出的二进制文件的格式</p><p>第三个选项：架构体系</p><p>第四个选项：矢量浮点处理器</p><p>第五个选项：应用程序二进制接口</p><p>第六个选项：浮点运算规则</p><p>第七个选项：选择指令集</p></blockquote><p><img src="/2022/03/02/F1C100S-Note3/21.png" alt="21"></p><center>图21</center><p>​        进入 Build options 选项，修改编译时使用的库类型为 both static and shared （同时使用静态库和动态库），保存返回上一级（如 图22 所示）。</p><p><img src="/2022/03/02/F1C100S-Note3/22.png" alt="22"></p><center>图22</center><p>​        进入 Toolchain（工具链） 选项，勾选上 Enable WCHAR support  ，Thread library debugging ，以及框选的选项（如 图23 所示），保存返回上一级。</p><p><img src="/2022/03/02/F1C100S-Note3/23.png" alt="23"></p><center>图23</center><p>​        进入 System configuration（系统配置） 选项，System banner 表示启动根文件系统后输出的信息，Root password 该选项可以修改登录密码（如 图24 所示），保存退出图形配置界面。</p><p><img src="/2022/03/02/F1C100S-Note3/24.png" alt="24"></p><center>图24</center><p>​        执行以下命令编译根文件系统，期间可能需要科学上网 (～￣▽￣)～</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p><img src="/2022/03/02/F1C100S-Note3/25.png" alt="25"></p><center>图25</center><p>​        编译完成后进入 <em>output/images</em> 目录，找到 rootfs.tar 文件（如 图26 所示）将其解压拷贝进上一环节创建的 TF 卡 rfoots 分区。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xvf rootfs.tar -C /media/z/rootfs/</span><br></pre></td></tr></table></figure><p><img src="/2022/03/02/F1C100S-Note3/26.png" alt="26"></p><center>图26</center><p>​        上电启动后，可以在 SecureCRT 中看到串口输出信息（如 图27 所示），很完美…踩坑了😭</p><p><img src="/2022/03/02/F1C100S-Note3/27.png" alt="27"></p><center>图27</center><p>​        原因是需要修改设备树增加 mmc，具体操作后续补上。</p><center>修</center><center>改</center><center>设</center><center>备</center><center>树</center><p>​        上电启动后，在 SecureCRT 中看到串口输出信息（如 图28 所示），又踩坑了…😤</p><p><img src="/2022/03/02/F1C100S-Note3/28.png" alt="28"></p><center>图28</center><p>​        根据错误（error -8）提示  <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/include/uapi/asm-generic/errno-base.h">查表</a>（知道 ENOEXEC    8   /<em> Exec format error </em>/   即格式错误），和 <em>/sbin/init</em> 这个文件有关，进入 <em>/sbin</em> 目录输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -la init</span><br></pre></td></tr></table></figure><p>​        得知其指向 <em>/bin/busybox</em> 这个文件，说明问题出在 busybox 这个文件上。再仔细一看，丫的 busybox 是红色…😂 没有执行权限，运行不出问题才怪呢！执行 chmod 777 命令给予读、写、执行权限。 </p><p><img src="/2022/03/02/F1C100S-Note3/29.png" alt="29"></p><center>图29</center><p>​        重新运行后观察串口打印，发现还是一样的错误，这是为什么呢？通过对比 TF 卡里的 <em>busybox</em> 和刚编译的 <em>busybox</em> （如 图30 所示）发现可能是在执行 sudo tar -xvf rootfs.tar -C /media/z/rootfs/ 命令将其解压到 TF 卡 <em>rootfs</em> 分区时出了问题。</p><p><img src="/2022/03/02/F1C100S-Note3/30.png" alt="30"></p><center>图30</center><p>​        修改后新运行后观察串口打印，发现软连接拷贝不完全（如 图31 所示），输入以下命令查看建立的软链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -il</span><br></pre></td></tr></table></figure><p><img src="/2022/03/02/F1C100S-Note3/31.png" alt="31"></p><center>图31</center><p>​        得到 <code>libc.so.0 -&gt; libuClibc-1.0.28.so</code> ，接下来删除软链接 libc.so.0 再重新软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf libc.so.0</span><br><span class="line">sudo ln -s libuClibc-1.0.28.so libc.so.0</span><br></pre></td></tr></table></figure><p><img src="/2022/03/02/F1C100S-Note3/32.png" alt="32"></p><center>图32</center><p>​        打开 SecureCRT 可以看到正常启动了，输入用户名和密码，默认用户名是 <em>root</em>，密码之前我们修改过是 <em>19010204</em> （如 图33 所示）</p><p><img src="/2022/03/02/F1C100S-Note3/33.png" alt="33"></p><center>图33</center><h3 id="busyBox-制作根文件系统"><a href="#busyBox-制作根文件系统" class="headerlink" title=" busyBox 制作根文件系统"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> busyBox 制作根文件系统</i></h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F1C100S踩坑记录（二）</title>
      <link href="/2022/03/01/F1C100S-Note2/"/>
      <url>/2022/03/01/F1C100S-Note2/</url>
      
        <content type="html"><![CDATA[<h2 id="kernel-内核移植"><a href="#kernel-内核移植" class="headerlink" title=" kernel 内核移植"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> kernel 内核移植</i></h2><h3 id="下载解压-LicheePI-nano-的-kernel"><a href="#下载解压-LicheePI-nano-的-kernel" class="headerlink" title=" 下载解压 LicheePI nano 的 kernel"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 下载解压 LicheePI nano 的 kernel</i></h3><p>​        因为 LicheePI nano 采用的芯片为 F1C100S，所以我们同样采用 LicheePI Nano 的 kernel 进行移植（<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.7.1.tar.gz">下载链接</a>），紧接上一步我们执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">mkdir kernel</span><br><span class="line">cd /home/z/Downloads/</span><br><span class="line">cp linux-5.7.1.tar.gz /home/z/linux/F1C100S/kernel/</span><br><span class="line">cd /home/z/linux/F1C100S/kernel/</span><br><span class="line">tar -zxvf linux-5.7.1.tar.gz</span><br></pre></td></tr></table></figure><p>​        指定编译时的交叉工具链和架构，打开 <em>kernel</em> 目录下的 Makefile 文件进行修改（如 图12 所示），命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim Makefile</span><br></pre></td></tr></table></figure><p><img src="/2022/03/01/F1C100S-Note2/12.png" alt="12"></p><center>图12</center><p>​        修改 CROSS_COMPILE 变量为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH?=arm</span><br><span class="line">CROSS_COMPILE ?=arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><p>​        接下来配置源码，下载 licheepi_nano 的配置文件（<a href="/download/linux-licheepi_nano_defconfig">下载链接</a>） linux-licheepi_nano_defconfig 将该文件拷贝到 <em>linux-5.7.1/arch/arm/configs</em> 目录下（如 图13 所示）。回到 kernel 根目录下执行以下命令编译该配置文件（到此内核配置完成）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make linux-licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><p><img src="/2022/03/01/F1C100S-Note2/13.png" alt="13"></p><center>图13</center><h3 id="修改-kernel-图形界面配置文件"><a href="#修改-kernel-图形界面配置文件" class="headerlink" title=" 修改 kernel 图形界面配置文件"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 修改 kernel 图形界面配置文件</i></h3><p>​        先进入 menuconfig 图形配置界面，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><blockquote><p>Y    -    includes     表示将该模块编译进内核</p><p>N    -    excludes    表示不编译模块</p><p>M    -    modularizes features    表示编译该模块但不编译进内核</p></blockquote><p>​        目前暂时先不修改配置（主要是咱现在也不咋会🤣 先使用默认配置 后续咱研究明白后再更新这一环节），保存退出 menuconfig 界面。</p><h3 id="编译-kernel-内核"><a href="#编译-kernel-内核" class="headerlink" title=" 编译 kernel 内核"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 编译 kernel 内核</i></h3><p>​        输入以下代码进行 kernel 内核编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure><p>​        编译完成后进入 <em>arch/arm/boot</em> 目录，可以看到生成了 Linux 内核镜像 zImage 文件（zImage 的作用实际上就是对内核进行解码），进入 <em>arch/arm/boot/dts</em> 目录，可以看到生成了设备树 dtb 文件。</p><p><img src="/2022/03/01/F1C100S-Note2/14.png" alt="14"></p><h3 id="烧写"><a href="#烧写" class="headerlink" title=" 烧写"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 烧写</i></h3><p>​        从一步的 u-boot 移植环节中的 bootcmd 配置（如 图15 所示）可以知道需要将 zImage 和 suniv-f1c100s-licheepi-nano.dtb 文件复制到 TF 卡的 0:1 分区中。</p><p><img src="/2022/03/01/F1C100S-Note2/15.png" alt="15"></p><center>图15</center><p>​        下面来使用 gparted 软件对 TF 卡进行分区，在终端中输入以下命令安装 gparted 软件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><p>​        在命令行中输入以下命令运行 gparted 软件（如 图16 所示）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gparted</span><br></pre></td></tr></table></figure><p><img src="/2022/03/01/F1C100S-Note2/16.png" alt="16"></p><center>图16</center><p>​        选中未分配空间点击鼠标右键新建，设置之前的空余空间为 1 MiB（该空间用于存放 uboot 系统），设置新大小为 32 MiB（该空间用于存放 zImage 文件和 dtb 文件），因为 uboot 中的 bootcmd 参数使用的是 FAT 的分区表格式，所以这里初始化为 fat16 格式（如 图17 所示）。</p><p><img src="/2022/03/01/F1C100S-Note2/17.png" alt="17"></p><center>图17</center><p>​                新建第二个分区为根文件系统分区，设置之前的空余空间为 0 MiB，设置新大小为 32 MiB（该空间用于存放根文件系统），初始化为 ext4 格式（如 图18 所示）。</p><p><img src="/2022/03/01/F1C100S-Note2/18.png" alt="18"></p><center>图18</center><p>​        点击 ✔ 应用操作到设备，（如 图19 所示）。</p><p><img src="/2022/03/01/F1C100S-Note2/19.png" alt="19"></p><center>图19</center><p>​        接着将 zImage 和 suniv-f1c100s-licheepi-nano.dtb 拷贝到 TF 卡第一个分区 boot 中。上电启动后，可以在 SecureCRT 中看到串口输出信息（如 图20 所示）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp zImage /media/z/BOOT</span><br><span class="line">cp suniv-f1c100s-licheepi-nano.dtb /media/z/BOOT</span><br></pre></td></tr></table></figure><p><img src="/2022/03/01/F1C100S-Note2/20.png" alt="20"></p><center>图20</center>        <p>​        可以看到内核已经成功启动，接下来进行 rootfs 移植。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>F1C100S踩坑记录（一）</title>
      <link href="/2022/03/01/F1C100S-Note1/"/>
      <url>/2022/03/01/F1C100S-Note1/</url>
      
        <content type="html"><![CDATA[<p>一个完整的嵌入式 Linux 系统，大致包括以下几部分</p><ul><li>u-boot     引导加载程序（相当于一个非常简单的操作系统）</li><li>kernel      内核（包含操作系统的核心子系统，以及所需的硬件驱动）    </li><li>rootfs       根文件系统（根目录下面放的那堆二进制应用）</li></ul><h1 id="U-boot-系统移植"><a href="#U-boot-系统移植" class="headerlink" title=" U-boot 系统移植"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> U-boot 系统移植</i></h1><h2 id="克隆-LicheePI-nano-的u-boot"><a href="#克隆-LicheePI-nano-的u-boot" class="headerlink" title=" 克隆 LicheePI nano 的u-boot"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 克隆 LicheePI nano 的u-boot</i></h2><p>​        因为 LicheePI nano 采用的芯片为 F1C100S，所以我们采用 LicheePI Nano 的 u-boot 进行移植。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Lichee-Pi/u-boot.git</span><br></pre></td></tr></table></figure><p>​        克隆完毕后进入该目录，切换到 nano 分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd u-boot/</span><br><span class="line">git checkout nano-v2018.01</span><br></pre></td></tr></table></figure><p>​        我们可以查看当前分支是否切换成功，命令如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p><img src="/2022/03/01/F1C100S-Note1/1.png" alt="1"></p><p>​        指定 u-boot 的交叉工具链和架构，打开 <em>u-boot</em> 目录下的 Makefile 文件进行修改，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim Makefile</span><br></pre></td></tr></table></figure><p>​        将 CROSS_COMPILE 变量修改为：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm</span><br><span class="line">CROSS_COMPILE=arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><p><img src="/2022/03/01/F1C100S-Note1/2.png" alt="2"></p><h2 id="修改开发板对应的板级文件"><a href="#修改开发板对应的板级文件" class="headerlink" title=" 修改开发板对应的板级文件"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 修改开发板对应的板级文件</i></h2><p>​        进入 <em>configs</em> 目录（configs 目录下都是板级配置文件），通过 ls 命令查看当前所有的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd congigs/</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p>​        configs 目录下有 sipeed 配置好的 LicheePI nano 的默认板级配置文件，licheepi_nano_defconfig（从 TF 卡启动）和 licheepi_nano_spiflash_defconfig（从 SPI 启动），执行以下命令，配置板级文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">make licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><p><img src="/2022/03/01/F1C100S-Note1/3.png" alt="3"></p><h2 id="修改-U-Boot-图形界面配置文件"><a href="#修改-U-Boot-图形界面配置文件" class="headerlink" title=" 修改 U-Boot 图形界面配置文件"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 修改 U-Boot 图形界面配置文件</i></h2><p>​        接着修改 u-boot 中的<strong>环境变量</strong>，<strong>bootcmd</strong>（自动启动时执行的命令） 和 <strong>bootargs</strong>（传递给内核的启动参数）。</p><h3 id="环境变量-bootcmd"><a href="#环境变量-bootcmd" class="headerlink" title=" 环境变量 bootcmd"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 环境变量 bootcmd</i></h3><p>​        bootcmd 保存着 uboot 的默认命令，uboot 启动倒计时结束以后就会执行 bootcmd 中的命令<u>【这些命令一般都是用来启动 Linux 内核的，比如读取 EMMC 或者 NAND Flash 或者 TF 卡中的 Linux 内核镜像文件和设备树文件到 RAM 中，然后启动 Linux 内核==（在系统还未启动之前，系统镜像文件都存放在 Flash（TF 卡 或者 NAND ）中，在 SOC上，操作系统的代码会全部加载到内存中运行，不会在 Flash 中直接运行。其中一个原因是当前的 Flash 都是 NAND Flash，其不能直接寻址；另一个原因是 Flash 的运行速度很慢，不管是读还是写都远远小于 RAM，因此我们的首要工作是将 Linux 操作系统从 Flash 复制到 RAM 中，这个必须在 Linux 启动之前完成。）==。可以在 uboot 启动以后进入命令行设置 bootcmd 环境变量的值。如果 TF 卡 或者 NAND 中没有保存 bootcmd 的值，那么 uboot 就会使用默认的值，板子第一次运行 uboot 的时候都会使用默认值来设置 bootcmd 环境变量】</u>。下面是 F1C100S 的 bootcmd 启动参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage</span><br><span class="line">load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">bootz 0x80008000 - 0x80c08000</span><br></pre></td></tr></table></figure><p>✔    load mmc 命令：将 emmc 中的某个数据加载到内存的某个地址中</p><p>✔    load mmc 0:1 0x80008000 zImage 命令：将 mmc0 的第一个分区中的 zImage 加载到内存中的 0x80008000 处</p><p>✔    load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb 命令：将 mmc0  的第一分区中的 suniv-f1c100s-licheepi-nano.dtb 设备树文件加载到内存中的 0x80c08000 处</p><p>✔    bootz 0x80008000 - 0x80c08000 命令：启动内核命令，0x80008000 为内核的存放位置，0x80c08000 为设备树的存放位置</p><p>​        注意：开发板上只有一个 emmc（TF 卡）,uboot 在挂载 emmc 的时候会将该 emmc 编号 0，如果有两个 emmc，那就会有两个 emmc 号，即 emmc0 和 emmc1。 0:1 中的 0 表示第 0 个 emmc 的第一个分区，0:1 中的 1 表示该 emmc ，我们的 zImage 文件存放在 emmc（TF 卡）的第一个分区中。</p><p>​        接下来配置 uboot 中的 bootcmd 环境变量，先进入 menuconfig 图形配置界面，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><blockquote><p>Y    -    includes     表示将该模块编译进内核</p><p>N    -    excludes    表示不编译模块</p><p>M    -    modularizes features    表示编译该模块但不编译进内核</p></blockquote><p>​        将光标移到 bootcmd value 处（如 图4 所示）</p><p><img src="/2022/03/01/F1C100S-Note1/4.png" alt="4"></p><center>图4</center><p>​        键盘按下 Enter 键，进入编辑模式，输入以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage; load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb; bootz 0x80008000 - 0x80c08000</span><br></pre></td></tr></table></figure><h3 id="环境变量-bootargs"><a href="#环境变量-bootargs" class="headerlink" title=" 环境变量 bootargs"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 环境变量 bootargs</i></h3><p>​        内核的启动可以通过 bootcmd 来完成，接下来内核启动完毕后必须挂载在根文件系统(rootfs)，bootargs 保存着 uboot 传递给 Linux 内核的参数，该变量的<strong>作用是告诉内核根文件系统的位置和属性以及必要的配置</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw</span><br></pre></td></tr></table></figure><p>✔    console=ttyS0,115200    命令：终端为 ttyS0 即 COM1 ，波特率为 115200</p><p>✔    panic=5     命令：表示超时 5 秒后 Linux 内核仍未成功运行，就会执行 kernel panic</p><p>✔    rootwait    命令：在根文件系统就绪之前无限等待，即告诉内核挂载文件系统之前需要先加载相关驱动，一般 bootargs 中都要加上这个参数（目的是防止因 mmc 驱动还未加载就开始挂载驱动而导致文件系统挂载失败）</p><p>✔    root=/dev/mmcblk0p2    命令：表示根文件系统的位置在 mmc 的 0:2 分区处（/dev 是设备文件夹，内核在加载 mmc 驱动的时候会在根文件系统中生成 mmcblk0p2 设备文件，该设备文件其实就是 mmc 的 0:2 分区，即内核对文件系统的读写操作方式本质上就是读写 /dev/mmcblk0p2 该设备文件）</p><p>✔    earlyprintk     命令：在内核加载的过程中打印输出信息</p><p>✔    rw     命令：表示文件系统的操作属性（r — 读，w — 写权限）</p><p>​        将光标移到 Enable boot arguments 处（如 图5 所示），键盘输入 Y 开启该参数</p><p><img src="/2022/03/01/F1C100S-Note1/5.png" alt="5"></p><center>图5</center><p>​        接着将光标移到 Boot arguments  (NEW) 处，键盘按下 ENTER （如 图6 所示）</p><p><img src="/2022/03/01/F1C100S-Note1/6.png" alt="6"></p><center>图6</center><p>​        输入以下代码，并保存退出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw</span><br></pre></td></tr></table></figure><p><img src="/2022/03/01/F1C100S-Note1/7.png" alt="7"></p><center>图7</center><h3 id="编译"><a href="#编译" class="headerlink" title=" 编译"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 编译</i></h3><p>​        输入以下代码进行 u-boot 编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure><p>​        如果出现报错（如 图8 所示），是因为 F1C100S 芯片的内核为 ARM9，其架构使用的是 ARMv5 架构，该芯片内部没有浮点运算单元，而我之前安装的 arm-linux-gnueabihf 编译器只能编译带浮点运算单元的芯片，因此对于 F1C100S 这种不带浮点运算单元的芯片，要安装 arm-linux-gnueabi 编译器。</p><p><img src="/2022/03/01/F1C100S-Note1/8.png" alt="8"></p><center>图8</center><p>​        下载好后执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /home/z/Downloads</span><br><span class="line">cp gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz /usr/local/arm</span><br><span class="line">cd /usr/local/arm</span><br><span class="line">tar -vxjf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>​        vim 打开 profile 文件后，在末尾添加以下内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/usr/local/arm/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi/bin</span><br></pre></td></tr></table></figure><p>​        保存退出后重启 Ubuntu 系统，接着再执行编译命令。如果出现以下报错：</p><p><img src="/2022/03/01/F1C100S-Note1/9.png" alt="9"></p><p><img src="/2022/03/01/F1C100S-Note1/10.png" alt="10"></p><p>​        那么执行以下命令安装 python-dev 和 swig </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo apt-get install swig</span><br></pre></td></tr></table></figure><p>​        编译成功后（如 图11 所示）</p><p><img src="/2022/03/01/F1C100S-Note1/11.png" alt="11"></p><center>图11</center><h3 id="烧写"><a href="#烧写" class="headerlink" title=" 烧写"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 烧写</i></h3><p>​        使用 dd 命令将 u-boot-sunxi-with-spl.bin 进行块搬移烧录到 tf 卡的 8k 偏移处地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8</span><br></pre></td></tr></table></figure><p>​        到此 u-boot 移植完毕，接下来进行 kernel 内核移植。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Task_F1C100S</title>
      <link href="/2022/02/27/Task-F1C100S/"/>
      <url>/2022/02/27/Task-F1C100S/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-Card"><a href="#Linux-Card" class="headerlink" title="Linux-Card"></a>Linux-Card</h1><p>一切都源自于寒假宅家，在逛 B站大学时刷到了 MIYOO 开源掌机这个视频，so 俺又又又来造电子垃圾了( •̀ ω •́ )✧  基于全志 F1C100S SOC 整了一个 Linux 最小系统板。首先，随便画了个核心版（如图1 所示），采用四层板走线（信号层-地层-电源层-信号层）。</p><div class="checkbox green checked"><input type="checkbox" checked="checked">            <p>引出所有IO口</p>            </div><div class="checkbox green checked"><input type="checkbox" checked="checked">            <p>M.2 插槽</p>            </div><div class="checkbox green checked"><input type="checkbox" checked="checked">            <p>板载SPI Flash</p>            </div><div class="checkbox green checked"><input type="checkbox" checked="checked">            <p>一个电源指示灯和一个用户灯</p>            </div><p><img src="/2022/02/27/Task-F1C100S/F1C100S_CORE-16459534036641.png" alt="F1C100S_CORE"></p><center>图1 Core Board</center><p>接着又随便画了块底板，采用两层板走线（如图2所示）。</p><div class="checkbox green checked"><input type="checkbox" checked="checked">            <p>一个 TF Nano 卡座</p>            </div><div class="checkbox green checked"><input type="checkbox" checked="checked">            <p>3.5mm耳机插座</p>            </div><div class="checkbox green checked"><input type="checkbox" checked="checked">            <p>USB-A x2</p>            </div><div class="checkbox green checked"><input type="checkbox" checked="checked">            <p>USB-Serial x1</p>            </div><div class="checkbox green checked"><input type="checkbox" checked="checked">            <p>一个复位按键和一个 FEL 按键</p>            </div><div class="checkbox green checked"><input type="checkbox" checked="checked">            <p>一个1.8’ IPS LCD</p>            </div><p><img src="/2022/02/27/Task-F1C100S/F1C100S_BOTTOM.png" alt="F1C100S_BOTTOM"></p><center>图2 Bottom Board</center><p>放一张组装好后的图片，👏👏👏👏👏</p><p><img src="/2022/02/27/Task-F1C100S/Task_F1C100S.png" alt="Task_F1C100S"></p><p>系统镜像以及俺的开发笔记后续会更新到此博客，本次项目源文件开源，PCB文件下载链接在文章末尾。BOM 表在这 👉<a href="https://jan-z.top/html/F1C100S_Core.html">F1C100S_Core_Board (Ver1.0)</a>    /    <a href="https://jan-z.top/html/F1C100S_Bottom_Board.html">F1C100S_Bottom_Board (Ver1.0)</a></p><center>未</center><center>完</center><center>待</center><center>续</center><center>!</center><p>👇PCB源文件</p><p>📁 <a href="/download/F1C100S_CORE.rar">F1C100S_Core_Board (Ver1.0)</a>        </p><p>📁 <a href="/download/F1C100S_BOTTOM.rar">F1C100S_Bottom_Board (Ver1.0)</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Tanner Install</title>
      <link href="/2022/02/26/Install/"/>
      <url>/2022/02/26/Install/</url>
      
        <content type="html"><![CDATA[<h1 id="Tanner-Install"><a href="#Tanner-Install" class="headerlink" title="Tanner Install"></a>Tanner Install</h1><h2 id="一、以管理员身份运行setup-exe"><a href="#一、以管理员身份运行setup-exe" class="headerlink" title="一、以管理员身份运行setup.exe"></a>一、以管理员身份运行setup.exe</h2><p><img src="/2022/02/26/Install/1.png" alt="1"></p><h2 id="二、选择-Local-license"><a href="#二、选择-Local-license" class="headerlink" title="二、选择 Local license"></a>二、选择 Local license</h2><p><img src="/2022/02/26/Install/2.png" alt="2"></p><p>接下来一路默认</p><h2 id="三、选择-Install"><a href="#三、选择-Install" class="headerlink" title="三、选择 Install"></a>三、选择 Install</h2><p><img src="/2022/02/26/Install/3.png" alt="3"></p><p>继续一路默认</p><p>User name 和 Organization 随便填写即可</p><p><img src="/2022/02/26/Install/4.png" alt="4"></p><p>接下来设置安装路径，注意：安装路径不可有中文！！</p><p><img src="/2022/02/26/Install/5.png" alt="5"></p><p>继续默认</p><p>点击 Install 开始安装 </p><p><img src="/2022/02/26/Install/6.png" alt="6"></p><h2 id="四、安装-Tanner-EDA-Utilites"><a href="#四、安装-Tanner-EDA-Utilites" class="headerlink" title="四、安装 Tanner EDA Utilites"></a>四、安装 Tanner EDA Utilites</h2><p><img src="/2022/02/26/Install/7.png" alt="7"></p><p>一路Next，安装步骤参考上一环节</p><p>注意安装路径不要有中文！！！</p><p><img src="/2022/02/26/Install/8.png" alt="8"></p><p>继续默认</p><h2 id="五、安装-System-Driver"><a href="#五、安装-System-Driver" class="headerlink" title="五、安装 System Driver"></a>五、安装 System Driver</h2><p>一路默认 Next 即可</p><p>接着选择本地许可</p><p><img src="/2022/02/26/Install/9.png" alt="9"></p><h2 id="六、解压-patch-rar"><a href="#六、解压-patch-rar" class="headerlink" title="六、解压 patch.rar"></a>六、解压 patch.rar</h2><p>进入 Crack 文件夹</p><p><img src="/2022/02/26/Install/10.png" alt="10"></p><p><img src="/2022/02/26/Install/11.png" alt="11"></p><p>解压 patch.rar 并将解压出来的文件复制粘贴至安装目录(我这里是D:\Tanner EDA\Tanner Tools v16.0)</p><p><img src="/2022/02/26/Install/12.png" alt="12"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maix_Dock笔记（一）</title>
      <link href="/2022/01/19/Maix-Dock%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/01/19/Maix-Dock%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Maix-Dock-笔记（一）"><a href="#Maix-Dock-笔记（一）" class="headerlink" title="Maix Dock 笔记（一）"></a>Maix Dock 笔记（一）</h1><p>注意：该文档基于 Linux 开发环境，硬件基于 Sipeed M1 Dock。</p><h2 id="USB-驱动："><a href="#USB-驱动：" class="headerlink" title=" USB 驱动："></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> USB 驱动：</i></h2><ul><li>查看设备是否已经正确识别：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/ttyUSB*</span><br></pre></td></tr></table></figure><h2 id="串口连接"><a href="#串口连接" class="headerlink" title=" 串口连接"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 串口连接</i></h2><ul><li>安装 pyserial：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3 -m pip install pyserial</span><br></pre></td></tr></table></figure><ul><li>连接开发板：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python3 -m serial.tools.miniterm --raw --dtr 0 --rts 0 /dev/ttyUSB0 115200</span><br></pre></td></tr></table></figure><ul><li>复位开发板：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按两次键盘上的 Ctrl + T &amp;&amp; Ctrl + R</span><br></pre></td></tr></table></figure><ul><li>退出串口：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按键盘上的 Ctrl + ]</span><br></pre></td></tr></table></figure><h2 id="MicroPython-基础语法"><a href="#MicroPython-基础语法" class="headerlink" title=" MicroPython 基础语法"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> MicroPython 基础语法</i></h2><ul><li>函数：在 Python 中, 定义一个函数要使用  <em>def</em>  语句</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#格式：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line">    函数体</span><br><span class="line">    </span><br><span class="line"><span class="comment">#例：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">a,b</span>):</span><span class="comment">#def 关键字定义函数</span></span><br><span class="line"><span class="comment">##########函数体##########</span></span><br><span class="line">    <span class="keyword">if</span> a&gt;b:</span><br><span class="line">        <span class="keyword">return</span> a<span class="comment">#return 关键字设置返回值，a 是函数输入参数</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> b<span class="comment">#return 关键字设置返回值，b 是函数输入参数</span></span><br><span class="line"><span class="comment">##########函数体##########</span></span><br><span class="line">    </span><br><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(main(a, b))</span><br></pre></td></tr></table></figure><h2 id="存储系统（K210-M1-Dock）"><a href="#存储系统（K210-M1-Dock）" class="headerlink" title=" 存储系统（K210 M1 Dock）"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 存储系统（K210 M1 Dock）</i></h2><ul><li>Flash：    </li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">start：0x000000</th><th style="text-align:center">start：0x300000</th><th style="text-align:center">start：0xD00000</th></tr></thead><tbody><tr><td style="text-align:center">MaixPy.bin（固件区）</td><td style="text-align:center">xxx.kmodel（模型区）</td><td style="text-align:center">spiffs （文件系统区）</td></tr></tbody></table></div><ul><li><p>SD卡：</p><p>需满足以下要求：</p><pre><code>    1. 支持 SPI 模式    2. </code></pre></li></ul><h2 id="视觉（图像处理-by-—-MaixPy-IDE）"><a href="#视觉（图像处理-by-—-MaixPy-IDE）" class="headerlink" title=" 视觉（图像处理 by — MaixPy IDE）"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 视觉（图像处理 by — MaixPy IDE）</i></h2><ol><li><strong>获取图像常用函数（基于 sensor 库）：</strong></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor <span class="comment">#导入内置的sensor（摄像头）库</span></span><br><span class="line"></span><br><span class="line">sensor.reset() <span class="comment">#初始化摄像头</span></span><br><span class="line">sensor.set_pixformat(sensor.RGB565)  <span class="comment">#设置摄像头为RGB565格式（彩色，每个像素16bit）</span></span><br><span class="line">sensor.set_framesize(sensor.VGA)     <span class="comment">#分辨率为VGA</span></span><br><span class="line">                                     <span class="comment">#【VGA】 : 640x480</span></span><br><span class="line">                                     <span class="comment">#【QVGA】: VGA/4</span></span><br><span class="line">sensor.set_hmirror(<span class="number">0</span>)                <span class="comment">#设置摄像头水平镜像，1：开启水平镜像，0：关闭水平镜像</span></span><br><span class="line">sensor.set_vflip(<span class="number">0</span>)                  <span class="comment">#设置摄像头垂直翻转，1：开启垂直翻转，0：关闭垂直翻转</span></span><br><span class="line">sensor.set_jb_quality(<span class="number">100</span>)           <span class="comment">#设置传送给 IDE 图像的质量（0~100），数字越大质量越好</span></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)      <span class="comment">#跳过2000毫秒的帧,摄像头刚启动时，图像质量还没稳定，所以跳过一些图像</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    img = senseor.snapshot() <span class="comment">#截取当前图像，存放于变量 img 中</span></span><br><span class="line">    img = img.to_grayscale(copy=<span class="literal">False</span>)<span class="comment">#转换为灰度图像</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>sensor.set_pixformat(pixformat)</strong>    <strong>&gt;&gt;&gt;&gt;</strong>   <strong>设置相机模块的像素模式</strong></p><ul><li>参数：<br>​          -  <em>sensor.GRAYSCALE</em>        灰度模式，每个像素   8bit<br>​          -  <em>sensor.RGB565</em>              彩色模式，每个像素 16bit</li></ul></li><li><p><strong>senseor.snapshot()</strong>                              <strong>&gt;&gt;&gt;&gt;</strong>   <strong>从摄像头取一帧图像数据，返回值是一张图像的对象</strong></p></li><li><p><strong>sensor.set_hmirror(True)</strong>                   <strong>&gt;&gt;&gt;&gt;</strong>   <strong>水平方向翻转（镜像）</strong></p></li><li><p><strong>sensor.set_vflip((True)                   </strong>     <strong>&gt;&gt;&gt;&gt;</strong>   <strong>垂直方向翻转（镜像）</strong></p></li><li><p><strong>sensor.skip_frames(n, [, time])</strong>   </p><ul><li><p>参数：</p><p>​          -  n: 跳过 n 帧图像</p><p>​          -  time: 跳过指定时间，单位为ms</p></li><li><p>若 n 和 time 皆未指定，该方法跳过300毫秒的帧；</p></li><li><p>若二者皆指定，该方法会跳过 n 数量的帧，但将在 time 毫秒后返回</p></li></ul></li></ul><ol><li><strong>实战举例（图像二值化）</strong></li></ol><p>二值化：即将大于某个临界灰度值的像素灰度设为灰度极大值（255），小于这个值的设为灰度极小值（0）。（如图2所示）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sensor, image, time <span class="comment">#首先导入内置的sensor（摄像头）库</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化摄像头</span></span><br><span class="line">sensor.reset()</span><br><span class="line">sensor.set_pixformat(sensor.GRAYSCALE)  <span class="comment">#设置摄像头为RGB565格式，默认都是用RGB565即可</span></span><br><span class="line">                                        <span class="comment">#【像素模式】: sensor.GRAYSCALE：灰度，每个像素 8bit</span></span><br><span class="line">                                        <span class="comment">#            sensor.RGB565：   彩色，每个像素16bit</span></span><br><span class="line">sensor.set_framesize(sensor.VGA)        <span class="comment">#分辨率为VGA</span></span><br><span class="line">                                        <span class="comment">#【VGA】 : 640x480</span></span><br><span class="line">                                        <span class="comment">#【QVGA】: VGA/4</span></span><br><span class="line"></span><br><span class="line">sensor.skip_frames(time = <span class="number">2000</span>)         <span class="comment">#跳过2000毫秒的帧,摄像头刚启动时，图像质量还没稳定，所以跳过一些图像</span></span><br><span class="line"><span class="comment">#sensor.skip_frames(n, [, time])</span></span><br><span class="line"><span class="comment">#参数：</span></span><br><span class="line"><span class="comment">#   n: 跳过 n 帧图像</span></span><br><span class="line"><span class="comment">#   time: 跳过指定时间，单位为ms</span></span><br><span class="line"><span class="comment">#若 n 和 time 皆未指定，该方法跳过300毫秒的帧；</span></span><br><span class="line"><span class="comment">#若二者皆指定，该方法会跳过 n 数量的帧，但将在 time 毫秒后返回</span></span><br><span class="line"></span><br><span class="line">clock = time.clock()</span><br><span class="line"></span><br><span class="line"><span class="comment">#二值化：即将大于某个临界灰度值的像素灰度设为灰度极大值（255），小于这个值的设为灰度极小值（0）</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    clock.tick()</span><br><span class="line">    img = sensor.snapshot()</span><br><span class="line">    Histogram = img.get_histogram()           <span class="comment">#创建 histogram 类 - 直方图对象</span></span><br><span class="line">    Thresholds = Histogram.get_threshold()    <span class="comment">#使用Otsu’s 方法计算最佳阈值，将直方图分的每个通道为两半（常用于确定最佳的 image.binary() 阈值）</span></span><br><span class="line">    img.binary([(Thresholds.value(), <span class="number">255</span>)])   <span class="comment">#返回灰度图 Thresholds 的阈值</span></span><br><span class="line">    <span class="comment">#image.binary(thresholds, invert=False)</span></span><br><span class="line">    <span class="comment">#【thresholds】将 thresholds 内的图像部分的全部像素变为1白，将在阈值外的部分全部像素变为0黑</span></span><br><span class="line">    <span class="comment">#【invert】    将图像的0 1（黑 白）进行反转，默认为false不反转</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;每秒传输帧数:&quot;</span>,clock.fps(),<span class="string">&quot;fps&quot;</span>)    <span class="comment">#打印画面每秒传输帧数</span></span><br></pre></td></tr></table></figure><p><img src="/2022/01/19/Maix-Dock%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/二值化图片.png" alt="二值化图片"></p><center>图2</center><hr><center>未完待续</center><center>2022/01/30</center>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> K210 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2021/10/18/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/10/18/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p><strong>关机：shutdown -h + 时间</strong></p><p><em>eg：shutdown -h 5                     5分钟后关机</em></p><pre><code>   *shutdown -h now               立即关机*</code></pre><p><strong>重启：shutdown -r + 时间</strong></p><p><em>eg：shutdown -r 5                     5分钟后重启</em></p><pre><code>   *shutdown -r now               立即重启*</code></pre><p><strong>帮助：—help</strong></p><p><em>eg：cd —help</em></p><h2 id="su-和-sudo"><a href="#su-和-sudo" class="headerlink" title="su 和 sudo"></a>su 和 sudo</h2><h3 id="su："><a href="#su：" class="headerlink" title="su："></a>su：</h3><p>用于用户之间的切换</p><h3 id="sudo："><a href="#sudo：" class="headerlink" title="sudo："></a>sudo：</h3><p>让普通用户具有临时使用root权限的权利</p><h2 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h2><h3 id="切换命令：cd"><a href="#切换命令：cd" class="headerlink" title="切换命令：cd"></a>切换命令：cd</h3><p>cd /                                                 切换到根目录</p><p>cd /usr                                           切换到根目录下的usr目录</p><p>cd ../  或  cd ..                                切换到上一级目录</p><p>cd ~                                                切换到home目录</p><p>cd -                                                 切换上次访问的目录</p><h3 id="目录查看：ls"><a href="#目录查看：ls" class="headerlink" title="目录查看：ls"></a>目录查看：ls</h3><p>ls                                                    查看当前目录下的所有目录和文件</p><p>ls -a                                                查看当前目录下的所有目录和文件（包括隐藏文件）</p><p>ls -l                                                 列表查看当前目录下的所有目录和文件</p><p>ls /dir                                             查看指定目录下的所有目录和文件（eg：ls /usr）</p><p><em>注：(pwd：查看绝对路径)</em></p><h3 id="目录操作（增，删，改，查）"><a href="#目录操作（增，删，改，查）" class="headerlink" title="目录操作（增，删，改，查）"></a>目录操作（增，删，改，查）</h3><h4 id="创建目录-：mkdir"><a href="#创建目录-：mkdir" class="headerlink" title="创建目录 ：mkdir"></a>创建目录 ：mkdir</h4><p>mkdir aaa                                     在当前目录下创建一个名为<em>aaa</em>的目录</p><p>mkdir /usr/aaa                           在指定目录<em>usr</em>下创建一个名为<em>aaa</em>的目录</p><h4 id="删除目录：rm"><a href="#删除目录：rm" class="headerlink" title="删除目录：rm"></a>删除目录：rm</h4><p><strong>删除文件：</strong></p><p>rm 文件                                          删除当前目录下的文件</p><p>rm -f 文件                                      删除当前目录的的文件（不询问）</p><p><strong>删除目录：</strong></p><p>rm -r aaa                                      递归删除当前目录下的aaa目录</p><p>rm -rf aaa                                    递归删除当前目录下的aaa目录（不询问）</p><p><strong>全部删除：</strong></p><p>rm -rf *                                        将当前目录下的所有目录和文件全部删除</p><p>rm -rf /*                                     【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</p><p><strong><em>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</em></strong>。</p><h4 id="目录修改：mv-cp"><a href="#目录修改：mv-cp" class="headerlink" title="目录修改：mv / cp"></a>目录修改：mv / cp</h4><p><strong>重命名目录/剪切目录：                                                 mv</strong></p><p><em>eg： mv aaa bbb                           将目录 aaa 改为 bbb</em></p><pre><code>    *mv /usr/tmp/aaa/usr            将 usr/tmp目录下的 aaa 目录剪切到 /usr 目录下*</code></pre><p><strong>拷贝目录：                                                                     cp -r 目录位置名称 目标位置 （-r代表递归）</strong> </p><p><em>eg：cp /usr/tmp/aaa  /usr          将  usr/tmp 目录下的 <strong>aaa</strong>目录复制到  /usr 目录下</em> </p><p><strong><em>注：拷贝文件和压缩包时，不用写-r递归。</em></strong></p><h4 id="目录搜索：find-目录-参数-文件名称"><a href="#目录搜索：find-目录-参数-文件名称" class="headerlink" title="目录搜索：find 目录 参数 文件名称"></a>目录搜索：find 目录 参数 文件名称</h4><p><em>eg：find /usr/tmp -name ‘a**</em>‘   查找/usr/tmp目录下的所有以a开头的目录或文件*</p><h2 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h2><h3 id="新建文件：touch-文件名"><a href="#新建文件：touch-文件名" class="headerlink" title="新建文件：touch 文件名"></a>新建文件：touch 文件名</h3><p><em>eg： touch  aa.txt                    在当前目录创建一个名为 aa.txt 的文件</em></p><h3 id="删除文件："><a href="#删除文件：" class="headerlink" title="删除文件："></a>删除文件：</h3><p><strong>查看 rm 命令</strong></p><h3 id="修改文件：vi-或-vim"><a href="#修改文件：vi-或-vim" class="headerlink" title="修改文件：vi 或 vim"></a>修改文件：vi 或 vim</h3><h4 id="命令行模式："><a href="#命令行模式：" class="headerlink" title="命令行模式："></a>命令行模式：</h4><p>【1】控制光标移动：                ↑，↓，j</p><p>【2】删除当前行：                    dd </p><p>【3】查找：                               /字符</p><p>【4】进入编辑模式：                i o a</p><p>【5】进入底行模式：                :</p><h4 id="编辑模式："><a href="#编辑模式：" class="headerlink" title="编辑模式："></a>编辑模式：</h4><p>【1】ESC 退出编辑模式到命令行模式；</p><h4 id="底行模式："><a href="#底行模式：" class="headerlink" title="底行模式："></a>底行模式：</h4><p>【1】退出编辑：                        :q</p><p>【2】强制退出：                        :q!</p><p>【3】保存并退出：                    :wq</p><h3 id="打开文件："><a href="#打开文件：" class="headerlink" title="打开文件："></a>打开文件：</h3><p>命令：                                          vi 文件名</p><p>eg：vi aa.txt                               打开当前目录下的aa.txt文件</p><p><strong><em>注意：使用vi编辑器打开文件后，处于命令模式，并不能编辑，需进入编辑模式。</em></strong></p><p><strong>i,a,o：</strong></p><p><strong><em>i:                                                   在光标所在字符前开始插入</em></strong><br><strong><em>a:                                                  在光标所在字符后开始插入</em></strong><br><strong><em>o:                                                  在光标所在行的下面另起一新行插入</em></strong></p><h3 id="查看文件："><a href="#查看文件：" class="headerlink" title="查看文件："></a>查看文件：</h3><p><strong>【1】cat：                                   查看最后一屏</strong></p><p>  <em>eg：cat sudo.conf                     只能显示 sudo.conf 的最后一屏内容</em></p><p><strong>【2】more：                               百分比显示</strong></p><p>  <em>eg：more sudo.conf                  回车向下一行，空格向下一页，q退出查看</em></p><p><strong>【3】less：                                  翻页查看</strong></p><p>  <em>eg：ess sudo.conf                      PgUp 和 PgDn 向上和向下翻页，q退出查看</em></p><p><strong>【4】tail ：                                  指定行数查看</strong></p><p>  <em>eg：tail -10 sudo.conf                tail -10 查看 sudo.conf 文件的后10行，Ctrl+C 结束</em>  </p><h2 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h2><p><strong>命令：chmod [选项] 文件</strong> </p><p><em>eg:    chmod 755 file</em> 即：只允许创作者修改，不允许其他用户修改，但允许其他用户读取和执行</p><div class="table-container"><table><thead><tr><th style="text-align:center">文件类型</th><th style="text-align:center">属主权限</th><th style="text-align:center">属组权限</th><th style="text-align:center">其他用户权限</th></tr></thead><tbody><tr><td style="text-align:center"><strong>d</strong></td><td style="text-align:center"><strong>r        w       x</strong></td><td style="text-align:center"><strong>r       -       x</strong></td><td style="text-align:center"><strong>r       -       x</strong></td></tr><tr><td style="text-align:center">目录文件</td><td style="text-align:center">读    写   执行</td><td style="text-align:center">读    写   执行</td><td style="text-align:center">读    写   执行</td></tr><tr><td style="text-align:center"><strong>0~(2)~</strong></td><td style="text-align:center"><strong>1        1        1</strong></td><td style="text-align:center"><strong>1        0        1</strong></td><td style="text-align:center"><strong>1        0        1</strong></td></tr><tr><td style="text-align:center"><strong>0~(10)~</strong></td><td style="text-align:center"><strong>7</strong></td><td style="text-align:center"><strong>5</strong></td><td style="text-align:center"><strong>5</strong></td></tr></tbody></table></div><p>Linux 文件属性详解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">----文件类型【只显示软链接（软链接：类似于Windows的快捷方式）】</span><br><span class="line">  |</span><br><span class="line">       --- d: 目录</span><br><span class="line">   |</span><br><span class="line">       --- -: 普通文件</span><br><span class="line">  |</span><br><span class="line">       --- l: 链接文件</span><br><span class="line">----属主权限</span><br><span class="line">  |</span><br><span class="line">       --- r: 读权限</span><br><span class="line">      |</span><br><span class="line">       --- w: 写权限</span><br><span class="line">      |</span><br><span class="line">       --- x: 执行权限</span><br><span class="line">----属组权限</span><br><span class="line">  |</span><br><span class="line">       --- r: 读权限</span><br><span class="line">      |</span><br><span class="line">       --- w: 写权限</span><br><span class="line">      |</span><br><span class="line">       --- x: 执行权限</span><br><span class="line">----其他用户权限</span><br><span class="line">  |</span><br><span class="line">       --- r: 读权限</span><br><span class="line">      |</span><br><span class="line">       --- w: 写权限</span><br><span class="line">      |</span><br><span class="line">       --- x: 执行权限   </span><br></pre></td></tr></table></figure><h2 id="压缩及解压文件"><a href="#压缩及解压文件" class="headerlink" title="压缩及解压文件"></a>压缩及解压文件</h2><blockquote><p>Windows的压缩文件的扩展名:                              .zip/.rar</p><p>linux中的打包文件的扩展名：                                aa.tar    </p><p>linux中的压缩文件的扩展名：                                bb.gz   </p><p>linux中打包并压缩的文件的扩展名：                    .tar.gz</p></blockquote><h3 id="打包并压缩："><a href="#打包并压缩：" class="headerlink" title="打包并压缩："></a>打包并压缩：</h3><p><strong>命令：      tar -zcvf 打包压缩后的文件名 要打包的文件</strong>                                               </p><blockquote><p>z：        调用gzip压缩命令进行压缩</p><p>c：        打包文件</p><p>v：        显示运行过程</p><p>f：         指定文件名</p></blockquote><p><em>eg：tar -zcvf ab.tar.gz aa.txt bb.txt  或  tar -zcvf ab.tar.gz</em> *      即打包并压缩目录下的所有文件，并命名为ab.tar.gz</p><h3 id="解压："><a href="#解压：" class="headerlink" title="解压："></a>解压：</h3><p><strong>命令：      tar -zxvf 要解压的文件名</strong> </p><blockquote><p>x：        解压文件</p></blockquote><p><em>eg：tar -zxvf ab.tar</em>                    将 ab.tar 解压到当前目录下</p><pre><code>   *tar -zxvf ab.tar -C /usr*         将 ab.tar 解压到根目录/usr下 (-C：代表指定解压的位置)</code></pre><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><h3 id="grep："><a href="#grep：" class="headerlink" title="grep："></a>grep：</h3><h3 id="find："><a href="#find：" class="headerlink" title="find："></a>find：</h3><h3 id="locate："><a href="#locate：" class="headerlink" title="locate："></a>locate：</h3><p>可以让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用 <em>locate</em> 命令查不到最新变动过的文件，需在使用 <em>locate</em> 之前，先使用 <em>updatedb</em> 命令。</p><p><em>eg：</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updatedb          #更新数据库</span><br><span class="line">locate /etc/sh    #搜索etc目录下所有以sh开头的文件 </span><br><span class="line">locate pwd        #查找和pwd相关的所有文件</span><br></pre></td></tr></table></figure><h3 id="whereis："><a href="#whereis：" class="headerlink" title="whereis："></a>whereis：</h3><p>定位可执行文件、源代码文件、帮助文件在文件系统中的位置。</p><p><strong><em>注：(定位的文件属性属于原始代码，二进制文件，帮助文件)</em></strong></p><p><em>eg：</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">whereis -b bash               #显示bash 命令的二进制程序  </span><br><span class="line">bash: /bin/bash /etc/bash.bashrc /usr/share/bash    <span class="meta">#bash命令的二进制程序的地址  </span></span><br><span class="line">whereis -m bash               #显示bash 命令的帮助文件  </span><br><span class="line">bash: /usr/share/man/man1/bash<span class="number">.1</span>.gz  <span class="meta">#bash命令的帮助文件地址 </span></span><br></pre></td></tr></table></figure><h3 id="which："><a href="#which：" class="headerlink" title="which："></a>which：</h3><p>在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p><p><em>eg：</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which pwd  #查找pwd命令所在路径 </span><br><span class="line">which java  #查找path中java的路径</span><br></pre></td></tr></table></figure><h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><blockquote><p><strong>ifconfig：查看网卡信息</strong></p><p><strong>ping：查看与某台机器的连接情况</strong></p><p><strong>service network restart：重启网络</strong></p></blockquote><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><blockquote><p><strong>ps -ef：查看所有正在运行的进程</strong></p><p><strong>Ctrl + Alt + T：打开终端</strong></p><p><strong>clear：终端清屏</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX新建工程</title>
      <link href="/2021/10/12/note-STM32CubeMX/"/>
      <url>/2021/10/12/note-STM32CubeMX/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-STM32CubeMX-新建工程"><a href="#使用-STM32CubeMX-新建工程" class="headerlink" title="使用 STM32CubeMX 新建工程"></a><strong>使用</strong> <strong>STM32CubeMX</strong> <strong>新建工程</strong></h1><h2 id="新建工程"><a href="#新建工程" class="headerlink" title=" 新建工程"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> <strong>新建工程</strong></i></h2><p>File -&gt; New Project </p><p><img src="/2021/10/12/note-STM32CubeMX/1.png" alt="1"></p><h2 id="选择-CPU-型号"><a href="#选择-CPU-型号" class="headerlink" title=" 选择 CPU 型号"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> <strong>选择</strong> <strong>CPU</strong> <strong>型号</strong></i></h2><p>选择CPU型号(例如：STM32F103ZETx)</p><p><img src="/2021/10/12/note-STM32CubeMX/2.png" alt="2"></p><p>界面详解：</p><p><img src="/2021/10/12/note-STM32CubeMX/9.png" alt="9"></p><p>① <strong><em>Categories：</em></strong> 种类选择 <em>（即将MCU的各种外设和资源分类，供用户选择使用）</em></p><p>​     <strong><em>A-Z：</em></strong>               顺序选择<em>（即将MCU的各种外设和资源按 <strong>A-Z</strong> 排序，供用户选择使用）</em></p><p>②<strong>外设配置：</strong>      设置所选择外设的各种功能</p><p>③<strong>预览界面：</strong>      引脚预览 和 系统预览</p><h2 id="确认时钟源"><a href="#确认时钟源" class="headerlink" title=" 确认时钟源"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> <strong>确认时钟源</strong></i></h2><p>打开 System Core -&gt;  RCC 选项, 选择 Crystal/Ceramic Resonato(外部晶振) 作为 HSE 的时钟源。</p><p><em>注： ①HSE：外部高速时钟(输入管脚是OSC_IN和OSC_OUT)   ②HSI：高速内部时钟   ③LSE：低速外部时钟，输入管脚是OSC32_IN和OSC32_OUT（32.768kHz） 。</em></p><p><img src="/2021/10/12/note-STM32CubeMX/3.png" alt="3"></p><h2 id="配置-IO-口"><a href="#配置-IO-口" class="headerlink" title=" 配置 IO 口"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> <strong>配置</strong> <strong>IO</strong> <strong>口</strong></i></h2><p><img src="/2021/10/12/note-STM32CubeMX/6.png" alt="6"></p><h2 id="配置系统时钟"><a href="#配置系统时钟" class="headerlink" title=" 配置系统时钟"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> <strong>配置系统时钟</strong></i></h2><p><img src="/2021/10/12/note-STM32CubeMX/4.png" alt="4"></p><p><strong>标号③：</strong>PLLSource MUX(锁相环时钟源选择器)，选择 “HSE”，即：8MHz外部晶振谐振体。</p><p>​               PLLNul(锁相环倍频）</p><p><strong>System Clock MUX(系统时钟选择器)：</strong></p><p>​                         1. HSI：芯片内部时钟信号（HSI时钟信号由内部8MHz的RC振荡器产生，可直接作为系统时钟或在2分频后作为PLL输入）</p><p>​                         2. HSE：高速外部时钟信号</p><p>​                         3. PLL（以下述时钟源之一为输入）：</p><p>​                                       1. HSI时钟除2</p><p>​                                       2. HSE或通过一个可配置分频器的PLL2时钟</p><p><strong>HCLK（高性能总线时钟）:</strong>  72MHz</p><p><strong>Cortex System timer：</strong> 配置为HCLK的1/8</p><p><strong>APB1 Peripheral clocks（低速外设总线时钟）：</strong>配置为HCLK的2分频</p><p><strong>APB2 Peripheral clocks（高速外设总线时钟）：</strong>配置为HCLK的1分频</p><p><a href="https://blog.csdn.net/as480133937/article/details/98845509">系统时钟RCC详解</a> &lt;— 大佬的文章</p><h2 id="进一步配置-IO-的具体属性"><a href="#进一步配置-IO-的具体属性" class="headerlink" title=" 进一步配置 IO 的具体属性"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> <strong>进一步配置</strong> <strong>IO</strong> <strong>的具体属性</strong></i></h2><p>点击 Confifiguration，进入系统详细配置，选择 GPIO，配置IO 的电平，GPIO模式，无上下/上/下拉，最大输出速度，引脚标签。</p><p><img src="/2021/10/12/note-STM32CubeMX/5.png" alt="5"></p><h2 id="配置工程属性"><a href="#配置工程属性" class="headerlink" title=" 配置工程属性"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> <strong>配置工程属性</strong></i></h2><p><strong>Pinout &amp; Configuration -&gt; SYS 设置Debug</strong></p><p><img src="/2021/10/12/note-STM32CubeMX/7.png" alt="7"></p><p><strong>-&gt; Project Manage, 配置工程的名称，路径，使用的 IDE 工具，堆栈大小。</strong></p><p><img src="/2021/10/12/note-STM32CubeMX/8.png" alt="8"></p><p><strong><em>(注意不要使用中文路径和工程名称)</em></strong></p><p><img src="/2021/10/12/note-STM32CubeMX/10.png" alt="10"></p><p><strong><em>Copy all used libraries into the project folder</em></strong>：</p><p>优点：后续需要新增其他外设或不再用STM32CubeMX时移植方便</p><p>缺点： 体积大，编译时间长(很长)</p><p><strong><em>Copy only the necessary library files</em>：</strong>    （<strong><em>Recommend</em></strong>）</p><p>优点：体积相对小，编译时间短，并且工程可复制拷贝</p><p>缺点： 新增外设时需要重新用STM32CubeMX导入 </p><p><strong><em>Add necessary library files as reference in the toolchain project configuration file：</em></strong></p><p>优点：体积小，比较节约硬盘空间</p><p>缺点： 复制到其他电脑上或者软件包位置改变，就需要修改相对应的路径 </p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title=" 生成代码"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> <strong>生成代码</strong></i></h2><p>点击 <strong><em>GENERATE CODE</em></strong>, 即在设定的路径成功生成代码</p><p><img src="/2021/10/12/note-STM32CubeMX/11.png" alt="11"></p><h2 id="添加用户测试代码"><a href="#添加用户测试代码" class="headerlink" title="添加用户测试代码"></a><strong>添加用户测试代码</strong></h2><p><img src="/2021/10/12/note-STM32CubeMX/12.png" alt="12"></p><p><img src="/2021/10/12/note-STM32CubeMX/13.png" alt="13"></p><p><strong>注：代码编写在BEGIN 和 END之间，更新时不会被覆盖。</strong></p><h2 id="配置下载调试工具"><a href="#配置下载调试工具" class="headerlink" title=" 配置下载调试工具"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> <strong>配置下载调试工具</strong></i></h2><p><img src="/2021/10/12/note-STM32CubeMX/14.png" alt="14"></p><p><img src="/2021/10/12/note-STM32CubeMX/15.png" alt="15"></p><h2 id="下载验证"><a href="#下载验证" class="headerlink" title=" 下载验证"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> <strong>下载验证</strong></i></h2><hr><p>END</p><p>2021/10/12</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown基本语法</title>
      <link href="/2021/08/01/hello-world/"/>
      <url>/2021/08/01/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="MarkDown基本语法"><a href="#MarkDown基本语法" class="headerlink" title="MarkDown基本语法"></a>MarkDown基本语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title=" 标题"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 标题</i></h2><p># + 标题名字（井号的个数代表标题的级数）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h2 id="文字"><a href="#文字" class="headerlink" title=" 文字"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 文字</i></h2><h3 id="斜体"><a href="#斜体" class="headerlink" title=" 斜体"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 斜体</i></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span> </span><br></pre></td></tr></table></figure><h3 id="加粗"><a href="#加粗" class="headerlink" title=" 加粗"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 加粗</i></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**加粗**</span> </span><br></pre></td></tr></table></figure><h3 id="斜体-加粗"><a href="#斜体-加粗" class="headerlink" title=" 斜体+加粗"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 斜体+加粗</i></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*斜体+加粗<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br></pre></td></tr></table></figure><h3 id="上标和下标"><a href="#上标和下标" class="headerlink" title=" 上标和下标"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 上标和下标</i></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上标：^x^</span><br><span class="line">下标：~x~</span><br></pre></td></tr></table></figure><p>eg：上标 x^2^ ；下标 x~2~</p><h3 id="删除线"><a href="#删除线" class="headerlink" title=" 删除线"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 删除线</i></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><h3 id="下划线"><a href="#下划线" class="headerlink" title=" 下划线"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 下划线</i></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快捷键（快捷键ctrl+u）</span><br></pre></td></tr></table></figure><h3 id="分隔线"><a href="#分隔线" class="headerlink" title=" 分隔线"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 分隔线</i></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三个或三个以上的 &#x27;<span class="emphasis">*&#x27;，&#x27;-&#x27; ,&#x27;_&#x27;</span></span><br></pre></td></tr></table></figure><p>eg：      </p><hr><hr><hr><h3 id="表情-smile-Ω"><a href="#表情-smile-Ω" class="headerlink" title=" 表情  :smile:  ;-)   Ω"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 表情  :smile:  ;-)   Ω</i></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快捷键win + .</span><br></pre></td></tr></table></figure><h3 id="表格与代码块"><a href="#表格与代码块" class="headerlink" title=" 表格与代码块"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 表格与代码块</i></h3><h4 id="表格"><a href="#表格" class="headerlink" title=" 表格"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 表格</i></h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name | price--- | ---xxxx | xxxxxx|xxx:---: 对齐</span><br></pre></td></tr></table></figure><p>例：</p><div class="table-container"><table><thead><tr><th>name</th><th>price</th></tr></thead><tbody><tr><td>xxxx</td><td>xxx</td></tr><tr><td>xxx</td><td>xxx</td></tr></tbody></table></div><h4 id="代码"><a href="#代码" class="headerlink" title=" 代码"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 代码</i></h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```+语言</span></span><br></pre></td></tr></table></figure><p>eg：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello!&#x27;</span>) </span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title=" 引用"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 引用</i></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;加一个空格</span><br></pre></td></tr></table></figure><p>eg： </p><blockquote><p>俺是个大帅哥</p><blockquote><p>俺最帅</p></blockquote></blockquote><h3 id="外部链接跳转"><a href="#外部链接跳转" class="headerlink" title=" 外部链接跳转"></a><i class="fa fa-link faa-horizontal animated-hover faa-slow"> 外部链接跳转</i></h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">name</span>](<span class="link">link</span>)</span><br></pre></td></tr></table></figure><p>eg:</p><p><a href="https://jan-z.top/">俺的blog</a></p><hr><p>END</p><p>2021/8/3</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
